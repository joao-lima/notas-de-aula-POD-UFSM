%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Classificação de dados}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Os algoritmos deste capítulo resolvem o {\bf problema de ordenação}:
\begin{itemize}
\item {\bf Entrada}: uma sequência de $n$ números $\langle a_1, a_2, ..., a_n \rangle$.

\item {\bf Saída}:  Uma permutação $\langle {a'}_1, {a'}_2, ..., {a'}_n \rangle$ da
entrada tal que ${a'}_1 \leq {a'}_2 \leq ... \leq {a'}_n$.
\end{itemize}
Ordenação pode ser usado em diversos outros algoritmos.
Ela pode ser necessária devido a requisitos do usuário, ou para a otimização de pesquisa 
como na pesquisa binária.

Em geral os dados são mantidos em um vetor onde cada objeto possui um
atributo \textbf{chave} que deve ser mantido ordenado.
Para fins de exemplo, utiliza-se números inteiros como elementos.

Um algoritmo de ordenação possui duas características principais:
\begin{itemize}
\item {\bf Estabilidade} -- relativo a manutenção da ordem original dos itens 
com chaves iguais.
	\begin{itemize}
	\item Um algoritmo de ordenação é {\bf estável} se a ordem relativa dos itens
		com chaves iguais não se altera durante a ordenação.
	\end{itemize}
\item {\bf Uso de memória} -- quanto ao uso de memória pelo algoritmo.
	\begin{itemize}
	\item {\bf Com cópia de dados} -- utiliza um vetor temporário para realizar a ordenação. As trocas são feitas entre o vetor original e o temporário.
	\item {\bf In-place} -- as trocas são feitas dentro do próprio vetor original.
	\end{itemize}
\end{itemize}

O critério de avaliação, sendo $n$ o número de registros, pode ser por:
\begin{itemize}
\item $C(n)$ -- número de comparações.
\item $M(n)$ -- número de movimentações de elementos.
\end{itemize}
Em grande parte dos casos, nos concentramos no número de comparações.

Os métodos de ordenação podem ser {\bf interno} (em memória primária) ou {\bf externo} (em memória secundária).
Na {\bf interna} o arquivo de entrada cabe todo na memória principal, enquanto
que na {\bf externa} o arquivo não cabe na memória principal. 

A maioria dos métodos é baseada em {\bf comparações} de chaves.
Porém, existem outros métodos que utilizam o principio da {\bf distribuição}. 
Um exemplo é ordenar um baralho com 52 cartas na ordem numérica e ordem de naipes.
O algoritmo seria:
\begin{enumerate}
\item Distribuir cartas em treze montes: ases, dois, três, ...., reis.
\item Coletar os montes na ordem especificada.
\item Distribuir novamente as cartas em quatro montes: paus, ouros, copas e espadas.
\item Coletar os montes na ordem especificada.
\end{enumerate}
Alguns desses métodos são o {\bf radixsort} e o {\bf bucketsort}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Classificação em memória primária}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Podem ser classificados como:
\begin{itemize}
\item {\bf Métodos simples} -- adequado para vetores pequenos, requerem $O(n^2)$ comparações.
Ex.: bolha, inserção, seleção, shellsort.
\item {\bf Métodos eficientes} -- adequados para vetores grandes, requerem $O(n \log n)$ comparações.
Ex.: quicksort, mergesort, heapsort.
\item {\bf Métodos mais eficientes} -- requerem $O(n)$ atribuições. Ex.: radixsort.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Bolha (\emph{bubble sort})}

O algoritmo é ilustrado na figura~\ref{aula03:algo:bubblesort}.
\begin{figure}[!htb]
\centering
\begin{framed}
\begin{lstlisting}
void Bubblesort( int *A, int n ){
	int i;
	bool trocado;
	do{
		trocado = false;
		for( i = 1; i < n; i++){
			if( A[i-1] > A[i] ){
				troca( A[i-1], A[i] );
				trocado = true;
			}
		}
	} while(trocado);
}
\end{lstlisting}
\end{framed}
\caption{Algoritmo do bubblesort.}
\label{aula03:algo:bubblesort}
\end{figure}

O número de comparações é $(n-1)+(n-2)+....+2+1$ com complexidade (para qualquer caso)
\begin{equation*}
C(n) = \sum_{k=1}^{n-1} i = \frac{n(n-1)}{2} = O(n^2).
\end{equation*}

As principais vantagens:
\begin{itemize}
\item Algoritmo simples.
\item Algoritmo estável.
\end{itemize}
Desvantagens:
\begin{itemize}
\item Se o vetor estiver ordenado, não melhora o tempo pois continua quadrático.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Seleção (\emph{selection sort})}

O algoritmo é ilustrado na figura~\ref{aula03:algo:selection}.
\begin{figure}[!htb]
\centering
\begin{framed}
\begin{lstlisting}
void Selecao( int *A, int n ){
	int i, j, min;
	for( i = 0; i < n; i++){
		min = i;
		for(j= i+1; j < n; j++)
			if( A[j] < A[min] )	min = j;
		troca( A[min], A[i] );
	}
}
\end{lstlisting}
\end{framed}
\caption{Algoritmo por seleção.}
\label{aula03:algo:selection}
\end{figure}

O número de comparações é $(n-1)+(n-2)+....+2+1$ com complexidade (qualquer caso)
\begin{equation*}
C(n) = \sum_{k=1}^{n-1} i = \frac{n(n-1)}{2} = O(n^2).
\end{equation*}

Vantagens:
\begin{itemize}
\item custo linear para movimentações.
\item interessante para vetores pequenos.
\end{itemize}
Desvantagens:
\begin{itemize}
\item vetor ordenado não ajuda, pois o custo continua quadrático.
\item algoritmo {\bf não é estável}.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Inserção (\emph{insertion sort})}

A figura~\ref{aula02:algo:insertion} da seção~\ref{aula02:sec:insertion} ilustra
o algoritmo.
%
O número de comparações é $(n-1)+(n-2)+....+2+1$ no pior caso (ordem reversa), com complexidade
\begin{equation*}
C(n) = \sum_{k=1}^{n-1} i = \frac{n(n-1)}{2} = O(n^2).
\end{equation*}
Por outro lado, o número de comparações no melhor caso (vetor ordenado) é 
$1 + 1 + 1 + 1+ .... + 1 = n-1$ com complexidade
\begin{equation*}
C(n) = n - 1  = O(n).
\end{equation*}

Vantagens:
\begin{itemize}
\item ideal quando o vetor está ``quase'' ordenado.
\item ordenação estável.
\end{itemize}
Desvantagens:
\begin{itemize}
\item custo médio é quadratico.
\item alto custo para inserir elemento na posição correta.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Shellsort}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Comparação dos métodos básicos}

\begin{table}[!ht]
\centering
\begin{tabular}{lccccc}
\hline
          & Melhor caso & Caso médio & Pior caso & Memória & Estável \\ \hline
Bubble    & $O(n)$ & $O(n^2)$ & $O(n^2)$ & $1$ & sim \\ \hline
Selection & $O(n^2)$ & $O(n^2)$ & $O(n^2)$ & $1$ & não  \\ \hline
Insertion & $O(n)$ & $O(n^2)$ & $O(n^2)$ & $1$ &  sim \\ \hline
Shellsort & $O(n)$ & $O(n^{\frac{3}{2}})$ & $O(n^{\frac{3}{2}})$ &  $1$ & não \\ \hline
\end{tabular}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Quicksort}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Mergesort}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Heapsort}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Counting sort}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Bucket sort}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Radix sort}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Classificação em memória secundária}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Exercícios}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

