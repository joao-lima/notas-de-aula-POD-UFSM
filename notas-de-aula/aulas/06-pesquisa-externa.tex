%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Pesquisa em memória secundária}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Este capítulo aborda questões relacionadas a técnicas de armazenamento
e recuperação de dados em memória secundária.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Memória secundária}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A classificação de dispositívos físicos pode ser feita ao considerar:
\begin{enumerate}
\item Desempenho no acesso aos dados.
\item Custo por unidade de dados.
\item Confiabilidade para casos de perda de dados em falhas de
energia ou falha do sistema, ou mesmo falha física do dispositívo.
\end{enumerate}
Também pode-se diferenciar armazenamento em:
\begin{description}
\item[Volátil] perde dados quando é desligado.
\item[Não-volátil] persistente mesmo quando é desligado. Inclui armazenamento
secundário e terciário.
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Mídias de armazenamento}

As médias de armazenamento disponíveis em geral são:
\begin{description}
\item[Cache] a mais rápida e custosa, volátil, e gerenciada pelo hardware
do processador.

\item[Memória principal] acesso rápido da ordem de 10 a 100 nanosegundos (1 nanosegundo = $10^{-9}$).
Em geral muito pequena (ou muito cara) para armazenar todos os dados de um banco de dados.
Hoje  em dia, em alguns casos, armazena todo o banco de dados (\emph{memcached}).
Ela é volátil, sendo que os dados são perdidos na falta de energia ou falha do sistema.

\item[Flash] dados sobrevivem em falhas de energia. Dados podem ser escritos em um local
uma única vez, porém podem ser escritos novamente.
Pode ser lida um número ilimitado de vezes, mas há um limite no  número de gravações
que varia entre 10K e 1M.
As leituras podem ser mais rápidas que a memória principal, mas as escritas
são lentas.
Muito usada em dispositivos embarcados como câmeras digitais, 
telefones, e memórias flash drive (pendrive).

\item[Magnética] dados são armazenados em uma mídia magnética com discos de movimento
giratório. 
Deve-se ler os dados do disco para a memória principal, e depois escrever de volta ao disco.
O acesso direto é possível em qualquer ordem, ao contrário de mídias de fita.


\item[Ótica] não volátil e os dados são lidos óticamente de um disco 
giratório através de um laser.
Os mais populares são CD-ROM (640 MB), DVD (4.7GB), e Blu-ray (27 GB a 54 GB).
As leituras e escritas são mais lentas comparadas a discos magnéticos.

\item[Fita magnética]
não volátil, usado primariamente para backup (recuperar falhas de disco), e 
arquivamento de dados.
O acesso é sequencial, muito mais lento que discos. Porém, a capacidade
de armazenamento é alta (40 a 300GB).
\end{description}

A figura~\ref{aula06:fig:media} ilustra a hierarquia de armazenamento de acordo com 
o desempenho e custo.
Os níveis mais altos são mais custosos, porém mais rápidos.
No sentido contrário, o custo por bit reduz, mas o tempo de acesso aumenta.
%
\begin{figure}[!htb]
\centering
\includegraphics[width=0.6\textwidth]{aula06-media}
\caption{Hierarquia de mídias de armazenamento.}
\label{aula06:fig:media}
\end{figure}

Nessa hierarquia, podemos agrupar as mídias em:
\begin{description}
\item[Armazenamento primário] mais rápido mas volátil. Ex: cache, memória principal.

\item[Armazenamento segundário] próximo nível na hierarquia, não volátil,
acesso moderadamente rápido. Ex: memória flash, discos magnéticos.

\item[Armazenamento terciário] nível mais baixo, não volátil, tempo de acesso
lento. Também chamado armazenamento \emph{off-line}. Ex: fita magnética, armazenamento ótico.
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Disco magnético}

\subsubsection{Estrutura física}

Fisicamente, discos magnéticos são simples.
A figura~\ref{aula06:fig:hd} mostra o funcionamento interno de um disco.
%
\begin{figure}[!htb]
\centering
\includegraphics[width=0.6\textwidth]{aula06-hd}
\caption{Mecanismo de cabeças de leitura em um disco magnético.}
\label{aula06:fig:hd}
\end{figure}

Cada prato do disco tem duas superfícias com material magnético, onde a informação
é gravada.
O cabeçote de escrita-leitura (\emph{read-write head}) fica posicionada bem 
próxima a superfície do prato, e lê e escreve dados codificados magneticamente.
A superfície é dividida logicamente em {\bf trilhas}, que são subdivididas em 
\textbf{setores}. 
Um setor é a menor unidade que pode ser lida ou escrita do disco.
Em geral, um setor tem 512 bytes; há perto de 50K a 100K trilhas por prato, e 1
a 5 pratos por disco.

Os pratos são montados em braços de disco.
Para ler e escrever um setor, o braço do disco se move para posicionar o cabeçote
na trilha correta.
O prato gira, e os dados são lidos e/ou escritos a medida que o setor
passa pelo cabeçote.

Outro componente de discos é o {\bf controlador de disco} que faz a inteface 
entre o computador e o hardware do disco.
Ele aceita comandos de alto nível para ler e escrever setores.
Entre outras funções, garante checagem de erros.

\subsubsection{Medidas desempenho}

O \textbf{tempo de acesso} é o tempo que leva desde a solicitação de leitura/escrita
até o momento em que a transferência começa de fato. 
O tempo de acesso consiste em:
\begin{description}
\item[Tempo de busca] tempo que leva para reposicionar o braço na trilha correta.
O tempo médio de busca é 1/2 do pior tempo de busca, em geral 4 a 10 milisegundos.

\item[Latência rotacional] tempo que leva para o setor a ser acessado
aparecer debaixo do cabeçote. Latência média é 1/2 do pior caso, em geral
4 a 11 milisegundos em discos (5400 a 15000 rpm). 
\end{description}

A \textbf{taxa de transferência} é a taxa com que os dados são recuperados ou 
armazenados no disco. A taxa máxima é de 25 a 100 MB por segundo, e essa
taxa é menor para trilhas internas.

O \emph{Mean time to failure} (MTTF) é o tempo médio de funcionamento de um disco
sem falhas. 
Esse tempo varia entre 3 a 5 anos. 
A probabilidade de falhas em disco novos é baixa, que corresponde a um
``MTTF teórico'' de 500K a 1,2M horas.
Ou seja, um MTTF de 1,2M horas para um disco novo significa que dados 1000 novos discos,
na média um irá falhar a cada 1200 horas.

\subsubsection{Otimização de acessos}

A transferência de dados entre disco e memória ocorre em unidades de \textbf{blocos},
que são uma sequência continua de setores em uma única trilha.
O tamanho varia de 512 a vários kilobytes. Blocos pequenos podem implicar 
em várias transferencias do disco, enquanto que grandes blocos podem 
desperdiçar espaços devido a blocos parcialmente ocupados.
Um tamanho típico utilizado é de 4 a 16 kilobytes.

A otimização de acessos envolve \textbf{algoritmos de escalonamento} que são usados para ordenar o 
acesso às trilhas para minimizar o  movimento do braço.
O \textbf{algoritmo do elevador} funciona da seguinte forma:
\begin{enumerate}
\item move o braço do disco em uma direção (de dentro para fora ou de fora para dentro).
\item processa todas as requisições pendentes nessa direção.
\item reverte o movimento e repete a varredura.
\end{enumerate}

Outra forma de otimização é a \textbf{organização de arquivos} que otimiza o acesso ao
organizar os blocos, de modo a corresponder à forma com que os dados são acessados.
Exemplo é armazenar informações relacionadas em regiões próximas.
Arquivos podem se \textbf{fragmentar} com o passar do tempo.
Fragmentação acontece quando o arquivo é modificado, ou quando os blocos livres
estão espalhados, e novos arquivos tiverem que ocupar esses blocos.
O acesso sequencial a um arquivo fragmentado leva a maior movimentação do
braço do disco. 
Alguns sistemas possuem utilitários para \textbf{desfragmentar} o sistema
de arquivos, de modo a acelerar o acesso.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Organização de arquivos}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A pesquisa em memória secundária normalmente está associada a \textbf{pesquisa 
em bancos de dados}.
O banco de dados é armazenado como uma coleção de arquivos. Cada arquivo
é uma sequência de registros, e cada registro é uma sequência de campos.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Registros de tamanho fixo}

A estratégia mais simples é assumir \textbf{registros de tamanho fixo}.
Cada tabela possui o seu próprio arquivo, e cada arquivo possui registros
de um tipo específico de dado.
O cabeçalho possui informações de controle. Cada registro tem um ponteiro
especial, que aponta para o seu próximo registro.
O problema com essa abordagem é a ocupação parcial do bloco.
Por exemplo, cada registro ocupa 300 bytes e cada bloco ocupa 1024 bytes.
O cabeçalho ocupa 20 bytes. Qual o mínimo de espaço que será desperdiçado ?

Uma solução é permitir que registros cruzem a fronteira de um bloco. 
As alternativas para remoção do registro $i$ são:
\begin{enumerate}
\item mover registros $i+1$, ..., $n$ para $i$, ..., $n-1$.
\item mover registro $n$ para $i$.
\item não mover nada, ligar os registros vazios por uma \emph{free list}.
\end{enumerate}

Com \emph{free lists}, pode-se usar um ponteiro especial para guardar os registros livres.
Ela é uma representação mais eficiente que reusa o espaço destinado
aos atributos dos registros para guardar os ponteiros.
O cabeçalho possui informações de controle como ponteiro para o primeiro registro
com dados do bloco, e ponteiro para o primeiro registro livre do bloco.

O principal problema dessa abordagem é o desperdício de espaço dentro do bloco.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Registros de tamanho variável}

A estrutura de \textbf{slotted-page} é comumente utilizada para organizar
registros de tamanho variável dentro de um bloco.
A figura~\ref{aula06:fig:slotted} ilustra a estrutura.
%
\begin{figure}[!htb]
\centering
\includegraphics[width=0.8\textwidth]{aula06-slotted}
\caption{Estrutura do \emph{slotted-page}.}
\label{aula06:fig:slotted}
\end{figure}
O cabeçalho contém:
\begin{itemize}
\item número de registros.
\item localização e tamanho de cada registro.
\item fim do espaço livre no bloco.
\end{itemize}
Os registros podem ser movidos dentro de uma página para evitar espaços vazios
entre eles; as entradas no cabeçalho precisam ser atualizadas.
Ponteiros não apontam diretamente para o registro, mas apontam 
para o ponteiro de entrada do registro no cabeçalho.

Registros de tamanho variável aparecem em bancos de dados de diversas formas:
armazenameto de múltiplos tipos de conteúdo em um mesmo arquivo;
armazenamento de atributos que possuem tamanho variável.

Se as slotted-pages são do tamanho de um bloco, o problema dos registros que cruzam é eliminado.
Isso limita o tamanho dos registros em um banco de dados, o que é o caso padrão.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Organização de registros em arquivos}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Até agora, vimos como representar registros em uma estrutura de arquivo.
Há várias formas de organizar registros em arquivos:
\begin{description}
\item[Heap] um registro pode ser posicionado em qualquer lugar onde haja espaço.

\item[Sequencial] registros armazenados em ordem sequencial, com base
no valor da chave de busca de cada registro.

\item[Hashing] um função hash calculada com base em alguns atributos do 
registro. O resultado especifica em que bloco do arquivo do registro
deve ser posicionado.
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Organização de arquivos sequencial}

Adequada para aplicações que executam processamento sequencial sobre todo o arquivo.
Os registros do arquivo são ordenados por uma \textbf{chave de busca}.

A operação de remoção usa \emph{free lists} para registros de tamanho fixo.

A inserção localiza a posição onde o registro deve ser inserido e:
\begin{enumerate}
\item se houver espaço no bloco, insere no bloco.
\item se for o último registro, insere em um novo bloco.
\item se houver espaço em um bloco vizinho, distribuir. Caso contrário,
insere em um novo \textbf{bloco de estouro} (\emph{overflow block}).
\item de qualquer forma, as cadeias de ponteiros precisam ser atualizadas.
\end{enumerate}
O uso de blocos de estouro demanda a reorganização do arquivo de tempo em tempo
para restaurar a ordem sequencial.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Clusterização multitable}

Os registros de cada tabela podem ser armazenados em arquivos separados.
Em uma \textbf{clusterização multitable}, registros de tabelas diferentes são armazenados no mesmo 
arquivo.
A principal motivação para armazenar registros relacionados no mesmo bloco é minimizar
a entrada e saída.
A figura~\ref{aula06:fig:clustering1} ilustra a organização de um arquivo com clusterização.
Esse arquivo armazena registros de uma ou mais relações em cada bloco.
Tal organização permite a leitura de registros que podem satisfazer uma união por meio de 
uma leitura de bloco.
%
\begin{figure}[!htb]
\centering
\includegraphics[width=0.6\textwidth]{aula06-clustering1}
\caption{Estrutura de arquivo de uma clusterização multitable.}
\label{aula06:fig:clustering1}
\end{figure}

Essa organização é boa para consultas com relação, e consultas envolvendo um único
deparamento e seus professores.
Porém, ela é ruim para consultas somente de departamentos.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Sistemas de arquivos}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Em organizações de arquivos sequencias, cada tabela é armazenada em um arquivo.
O armazenamento poderia ser feito por meio do sistema de arquivos do sistema
operacional (SO).
A clusterização multitable pode trazer ganhos significativos em eficiência, mas 
essa organização não é compatível com o sistema de arquivos de sistemas operacionais.

Muitos dos sistemas de bancos de dados (SGBDs) de grande escala não utilizam diretamente o SO.
As tabelas são armazenadas em um único arquivo, e o SGBD gerencia o arquivos por conta própria.
Isso exige a implementação de um sistema de arquivos dentro do SGBD.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Buffer manager}

O  número de transferencias de blocos entre o disco e a memória pode ser
reduzido mantendo o maior número possível de blocos na memória principal.
Um \textbf{buffer} é a porção da memória principal disponível para armazenar cópias
de blocos de disco.
O \textbf{buffer manager} é responsável pela alocação de espaço do buffer na 
memória principal.

Programas utilizam o buffer manager quando precisam ler um bloco do disco:
\begin{enumerate}
\item se o bloco já estiver no buffer, o gerenciador retorna o endereço 
do bloco na memória principal.

\item se o bloco não estiver no buffer, o manager:
	\begin{enumerate}
	\item aloca espaço no buffer para o bloco.
		\begin{enumerate}
		\item substituindo algum outro bloco, se necessário, para
			liberar espaço para o novo bloco.
		\item o bloco substituído é escrito de volta no disco somente se ele foi
		modificado desde a última vez que ele foi escrito/recuperado do disco.
		\end{enumerate}
	\item Lê o bloco do disco para o buffer e retorna o endereço do bloco
		na memóra principal para o programa.
	\end{enumerate}
\end{enumerate}

Sua função é similar ao gerenciamento e memória virtual dos sistemas operacionais.
Porém, bancos de dados tem requisitos diferentes.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Políticas de substituição de blocos}

A maioria dos sistemas operacionais usam a política de substituição do bloco menos recentemente usado
ou \emph{least recently used} (LRU).
A ideia por trás do LRU é usar um padrão passado de referência a blocos como uma previsão de 
futuras referências, já que usualmente nada mais se conhece.
Consultas possuem um padrão de acesso bem definido, com varreduras sequenciais.
O sistema do BD pode usar informação contida na consulta para prever referências futuras.

O LRU pode ser uma estratégia ruim para certos tipos de acesso que envolvem varreduras repetidas.
Por exemplo, na junção de 2 tabelas $r$ e $s$ por um laço aninhado. 
Uma estratégia mista é preferível, onde o otimizador de consultas pode oferecer dicas
para substituição de blocos.

Outras técnicas do buffer manager são:
\begin{description}
\item[Pinned block] bloco em memória que não tem permissão de ser escrito
de volta no disco.

\item[Estratégia Toss-immediate]  libera o espaço ocupado por um bloco assim que 
a última tupla do bloco é processada.

\item[Estratégia MRU] MRU significa mais recentemente usado (\emph{most recently used}), onde 
o sistema marca o bloco sendo processado. Depois que a última tupla do bloco é processada,
o bloco é desmarcado, e se torna o bloco mais recentemente usado.

\item[Saída forçada] o manager também suporta saída forçada de blocos para fins de 
recuperação.
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Mecanismos de indexação}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Muitas buscas referenciam apenas uma pequena porção dos registros de um arquivo.
Seria ineficiente ler todos os registros para encontrar apenas uma tupla.
Usa-se estruturas adicionais a fim de permitir esse tipo de acesso.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Introdução}

Um índice de um arquivo funciona como o índice de um livro.
Mecanismos de indexação são utilizados para acelerar o acesso
aos dados.
Uma \textbf{chave de busca} (\emph{search key}) é/são o(s) atributo(s) usado(s)
para localizar registros em um arquivo.
Um \textbf{arquivo de índice} consiste em registros na forma \emph{chave -
pointeiro}.
Arquivos de índice são muito menores que o arquivo original.

Há dois tipos básicos de índices:
\begin{description}
\item[Índices ordenados] chaves de busca são armazenadas (encadeadas) em ordem.
\item[Índices hash]  chaves de busca são distribuídas uniformemente
em buckets usando uma função de hash.
\end{description}

As duas técnicas são estudadas. 
Nenhuma delas é considerada a melhor. 
Cada técnica é avaliada de acordo com os seguintes fatores:
\begin{description}
\item[Tipo de acesso eficiente]  como registros de um valor específico em um atributo. Esse fator
exerce bastante influência na escolha do tipo de índice.
\item[Tempo de acesso]
\item[Tempo de inserção]
\item[Tempo de remoção]
\item[Sobrecarga de espaço] sendo o espaço adicional para o índice.
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Índices ordenados}

Em um \textbf{índice ordenado}, as entradas são ordenadas de acordo
com o valor da chave de busca, como por exemplo pelo nome do autor em um catálogo.
Podem ser classificados quanto:
\begin{itemize}
\item A chave de busca indexada.
	\begin{itemize}
	\item índices primários.
	\item índices secundários.
	\end{itemize}
\item Aos registros indexados.
	\begin{itemize}
	\item índices densos.
	\item índices esparsos.
	\end{itemize}
\end{itemize}

O \textbf{índice primário}, em um arquivo sequencialmente ordenado, é o índice
cuja chave de busca é usada para ordenar o arquivo.
É também chamado de \textbf{índice clusterizado} (\emph{clustering index}).
A chave de busca de um índice primário é quase sempre a chave primária.

O \textbf{índice secundário} é um índice cuja chave de busca não está armazenada
de acordo com a ordem sequencial do arquivo.
Também chamado de \textbf{índice não clusterizado} (\emph{non-clustering index}).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Índices densos e esparsos}

Uma entrada no índice consiste em uma chave de busca e pointeiros para um ou mais registros.
O ponteiro para um registro consiste no identificador de um bloco do disco e um deslocamento
dentro do bloco para identificar o registro.
Há dois tipos de índices: denso e esparso.

\textbf{Índices esparsos} contém entradas no índice para apenas alguns valores de chave de busca.
Para localizar um registro com uma chave de busca $k$, deve-se:
\begin{enumerate}
\item encontrar a entrada com o maior valor de chave de busca $< k$.
\item varrer o arquivo sequencialmente a partir do resgistro apontado por essa entrada.
\end{enumerate}
Índices esparsos são somente aplicáveis quando os registros estão ordenados pela chave
de busca do índice.

Em \textbf{índices densos} registros do índice aparecem para todos os valores
de chave de busca do arquivo.
Índices primários podem ser densos ou esparsos, mas índices secundários
precisam ser densos.

A figura~\ref{aula06:fig:denso:esparso} ilustra um exemplo entre índices denso e esparso.
%
\begin{figure}[!htb]
\centering
  \begin{minipage}{0.45\textwidth}
	\centering
	\includegraphics[width=\textwidth]{aula06-denso1}
  \end{minipage}
  %
  \begin{minipage}{0.45\textwidth}
	\centering
	\includegraphics[width=\textwidth]{aula06-esparso1}
  \end{minipage}
\caption{Exemplo de um índice denso (esquerda) e esparso (direita).}
\label{aula06:fig:denso:esparso}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Índices multinível}

Para casos em que o índice primário não cabe em memória, o acesso torna-se caro.
Uma solução é tratar o índice primário em disco como um arquivo sequencial e
construir um índice esparso sobre ele.
O \textbf{índice externo} é um índice esparso do índice primário, e 
o \textbf{índice interno} é o arquivo do índice primário.

Se mesmo o índice externo for muito grande para caber na memória, outro nível
pode ser criado, e assim por diante.
Note que índices em todos os níveis devem ser atualizados quando ocorrer
atualizações no arquivo.
A figura~\ref{aula06:fig:multinivel} mostra um simples exemplo de índice esparso
construído de um índice primário.
%
\begin{figure}[!htb]
\centering
\includegraphics[width=0.4\textwidth]{aula06-multinivel1}
\caption{Índice esparso externo construído de um índice primário.}
\label{aula06:fig:multinivel}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Atualização de índice}

Em qualquer das formas de índice, cada índice precisa ser atualizado quando um
registro é inserido ou removido.

{\bf Remoção} - se o registro removido é o único registro no arquivo
com uma chave de busca, a chave de busca também é removida do índice.
Em índices densos, remoção de uma chave de busca é similar a remoção
de um registro de arquivo.
Em índices esparsos, se uma chave de busca existe no índice, ela é removida 
e substituída pela próxima chave de busca do arquivo.
Se a próxima chave de busca já for indexada, a entrada no índice é simplesmente 
removida.

{\bf Inserção} - em índíces densos, realiza uma busca no índice usando a chave de
busca do registro a ser inserido.
Se a chave não existe, ela é inserida no índice.
Em índices esparsos, se o índice mantem uma entrada para cada bloco do arquivo,
nenhuma mudança é necessária, a não ser que um novo bloco seja criado (ou sofra
distribuição).
Se um novo bloco for criado (ou sofrer distribuição), 
a primeira chave de busca nova do bloco é inserida no índice.

Em índices multinível, as inserções e remoções são simples extensões dos
algoritmos usados em índices de um nível só.
As inserções e remoções são propagadas dos níveis internos para os externos.

As atualizações dos índices significam atualizações nos blocos físicos
onde os índices estão armazenados.
A organização física e lógica desses blocos é feita de forma similar
aos blocos de um arquivo de dados.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Índices secundários}

Em índices secundários, registros do índice apontam para o bucket que contem pointeiros
para todos os registros com uma chave de busca.
A figura~\ref{aula06:fig:secundario} mostra um exemplo de índice secundário.
Note que índices secundários tem de ser densos.
%
\begin{figure}[!htb]
\centering
\includegraphics[width=0.6\textwidth]{aula06-secundario1}
\caption{Exemplo de índice secundário sobre o campo \emph{salary}.}
\label{aula06:fig:secundario}
\end{figure}

Índices oferecem benefícios substanciais na busca por registros.
Porém, atualizações de índices impõem sobrecustos em atualizações.

A varredura sequencial de um índice primário é eficiente, mas a 
varredura sequencial em índices secundários é cara pois é preciso
uma transferência de bloco do disco para cada acesso ao registro.
Uma transferência de bloco requer cerca de 5 a 10 milisegundos, contra
100 nanosegundos de um acesso à memória.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsection{conceitos basicos}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Índices em árvores B+}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A principal desvantagem de índices sequenciais é a perda de desempenho
a medida que o arquivo de índice cresce, tanto buscas e varreduras sequenciais.
Reorganizações periódicas são necessárias, mas reorganizações frequentes
são indesejadas.
\textbf{Índices em árvores B+} é um tipo de árvore balanceada que mantem a eficiência
mesmo com inserções e remoções.
Cada nó não-folha de uma árvore B+ tem entre $\lceil n/2 \rceil$ e $n$ filhos,
sendo $n$ fixo para uma árvore particular.

Árvores B+ tem a vantagem de se auto-organizar com modificações pequenas e
locais em inserções e remoções, além de não requerer a reorganização de todo o
arquivo para manter o desempenho.
Uma desvantagem menor é o sobrecusto de inserção e remoção para manter o 
balanceamento, além do sobrecusto em espaço.

A figura~\ref{aula06:fig:btree1} mostra um exemplo de árvore B+.
%
\begin{figure}[!htb]
\centering
\includegraphics[width=0.7\textwidth]{aula06-btree1}
\caption{Exemplo de uma árvore B+.}
\label{aula06:fig:btree1}
\end{figure}

Uma árvore B+ é uma árvore com raiz única que segue as seguintes propriedades:
\begin{itemize}
\item Todos os caminhos da raiz até as folhas tem o mesmo tamanho.
\item Cada nó que não seja raiz nem folha possui de $\lceil n/2 \rceil$
até $n$ filhos.
\item Um nó folha tem de $\lceil (n-1)/2 \rceil$ até $n-1$ valores.
\item Casos especiais:
	\begin{itemize}
	\item Se a raiz não é uma folha, ela possui pelo menos dois filhos.
	\item Se a raiz é uma folha (ou seja, é o único nó da árvore), ela
	pode ter de $0$ a $(n-1)$ valores.
	\end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Estrutura}

Um nó típico de árvore B+, como na figura~\ref{aula06:fig:btree2}, possui:
\begin{itemize}
\item $K_i$ são valores de chaves de busca.
\item $P_i$ são pointeiros para filhos (nós não folha), ou para
registros ou buckets de registros (para nós folha).
\end{itemize}
As chaves de busca de um nó são ordenadas com $K_1 < K_2 < K_3 < ... < K_{n-1}$.
Normalmente o nó tem o tamanho de um bloco.
%
\begin{figure}[!htb]
\centering
\includegraphics[width=0.4\textwidth]{aula06-btree2}
\caption{Um nó em uma árvore B+.}
\label{aula06:fig:btree2}
\end{figure}

As propriedades de um nó folha, como na figura~\ref{aula06:fig:btree3}, são:
\begin{itemize}
\item Para $i = 1, 2, ..., n-1$, o ponteiro $P_i$ aponta
para o registro com chave de busca $K_i$, ou para um bucket de apontadores para registros.
Buckets só são necessários se a chave de busca não for chave primária.
\item Se $L_i$, $L_j$ são nós folha e $i < j$, as chaves de busca de $L_i$
são menores que as chaves de busca de $L_j$.
\item $P_n$ aponta para o próximo nó folha na ordem da chave de busca.
\end{itemize}
%
\begin{figure}[!htb]
\centering
\includegraphics[width=0.6\textwidth]{aula06-btree3}
\caption{Exemplo de um nó folha ($n = 4$) de uma árvore B+.}
\label{aula06:fig:btree3}
\end{figure}

Ao passo que nós não folha formam um índice esparso multinível sobre os nós folha.
Para um nó não folha, como na figura~\ref{aula06:fig:btree2}, com $m$ ponteiros:
\begin{itemize}
\item Todas as chaves de busca da subárvore apontada por $P_1$ são 
menores do que $K_1$.
\item Para $2 \leq i \leq n-1$, todas as chaves de busca da sub-árvore apontada
por $P_i$ são maiores ou iguais a $K_{i-1}$ e menores que $K_i$.
\item Todas as chaves de busca da sub-árvore apontada por $P_n$ são maiores
ou iguais a $K_{n-1}$.
\end{itemize}

A figura~\ref{aula06:fig:btree4} ilustra um exemplo de árvore B+ com $n = 6$.
Baseado nessa figura, podemos afirmar que:
\begin{itemize}
\item Nós folha tem de 3 a 5 valores ($\lceil (n-1)/2 \rceil$ e $n-1$, com $n=6$).
\item Nós não folha (que não a raiz) tem de 3 a 6 filhos ($\lceil n/2 \rceil$ e
$n$ com $n=6$).
\item A raiz precisa ter pelo menos $2$ filhos.
\end{itemize}
%
\begin{figure}[!htb]
\centering
\includegraphics[width=0.8\textwidth]{aula06-btree4}
\caption{Árvore B+ com $n = 6$.}
\label{aula06:fig:btree4}
\end{figure}

Algums observações sobre árvores B+:
\begin{itemize}
\item Visto que as conexões entre nós são feitas por ponteiros, 
blocos ``logicamente'' próximos não precisam estar ``fisicamente'' 
próximos.

\item Os níveis não folha de uma árvore B+ formam uma hierarquia 
multinível de índices esparsos.

\item A árvore possui um número relativamente pequeno de níveis:
	\begin{itemize}
	\item O nível abaixo da raiz possui pelo menos $2 * \lceil n/2 \rceil$ valores.
	\item O próximo nível possui pelo menos $2 * \lceil n/2 \rceil * \lceil n/2 \rceil$ valores.
	\item ... etc.
	\item Se existem $K$ chaves de busca, a altura não é maior do que $\lceil \log_{n/2} K \rceil$.
	\item Por isso as buscas são eficientes.
	\end{itemize}
\item Inserções e remoções são eficientes, já que o índice é reestruturado em tempo 
logarítimico, como será visto adiante.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Busca}

Os passos na busca em árvores B+ para uma chave de busca de valor $V$
onde retorna $C$ e o índice $i$ tal que $C.P_i$ aponta para o primeiro registro
com chave de busca $V$:
\begin{enumerate}
\item C = raiz.
\item \textbf{Repete} enquanto $C$ não é um nó folha:
	\begin{enumerate}
	\item Seja $i= $ o menor número tal que $V \leq C.K_i$.
	\item \textbf{Se} não existir um $i$, então $C = C.P_m$ onde $P_m$ é o último ponteiro não-nulo do nó.
	\item \textbf{Senão} (existe um $i$):
		\begin{enumerate}
		\item \textbf{Se} $V = C.K_i$, então $C = C.P_{i+1}$.
		\item \textbf{Senão} $C = C.P_i$ ($V < C.K_i$).
		\end{enumerate}
	\end{enumerate}
\item Seja $i$ o valor mínimo tal que $K_i = V$.
\item \textbf{Se} existe um $i$, retorna $(C, i)$, \textbf{senão} retorna $null$.
\end{enumerate}

Se o arquivo de índice possui $K$ chaves de busca, a altura da árvore não
ultrapassa $\lceil \log_{\lceil n/2 \rceil} K \rceil$
Um nó é geralmente do mesmo tamanho de um bloco, tipicamente $4$ Kbytes, e 
$n$ é tipicamente cerca de 100 (40 bytes por entrada no índice).
Com 1 milhão de chaves de busca e $n= 100$, no máximo $\log_{50}(1,000,000) = 4$
nós são acessados em uma busca, ou seja, no máximo 4 acessos a blocos.
Compare isso com uma árvore binária balanceada com 1 milhão de chaves de busca,
que acessa cerca de 20 nós em uma busca.
A diferença é significativa já que cada acesso a nó requer um acesso a disco.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Atualização}

\subsubsection{Inserção}

Os passos para inserção em uma árvore B+ são:
\begin{enumerate}
\item Encontre o nó folha onde a chave de busca deveria aparecer.
\item Se a chave existir no nó folha:
	\begin{enumerate}
	\item Adicionar registro no arquivo.
	\item Adicionar o ponteiro no bucket.
	\end{enumerate}
\item Se a chave de busca não estiver presente:
	\begin{enumerate}
	\item Adicionar o registro no arquivo e criar o bucket.
	\item Se tiver espaço no nó folha, inserir par (chave, pointeiro).
	\item Senão, dividir o nó folha, junto com o novo par (chave-valor).
	\end{enumerate}
\end{enumerate}

A divisão do nó folha envolve os seguintes passos:
\begin{enumerate}
\item Pegar os $n$ pares (chave, apontador) (incluindo o novo) em ordem. Colocar os primeiros $\lceil n/2 \rceil$ no nó original e o restante no novo nó.
\item Considere que o novo nó é $p$, e $k$ é a menor chave em $p$. 
Inserir $(k,p)$ no pai do nó sendo dividido.
\item Se o pai estiver cheio, divida-o e propague a divisão para cima. A divisão prossegue até que se encontre um nó não cheio.
\end{enumerate}
%
Um exemplo de inserção é mostrado na figura~\ref{aula06:fig:btree6}.
%
\begin{figure}[!htb]
\centering
\includegraphics[width=0.8\textwidth]{aula06-btree6}
\includegraphics[width=0.8\textwidth]{aula06-btree7}
\caption{Árvore B+ antes e depois da inserção de ``Adams''.}
\label{aula06:fig:btree6}
\end{figure}

No pior caso, a raiz será dividida, aumentando a altura da árvore em uma
unidade.

Os passos na divisão de um nó não folha, quando ao inserir $(k,p)$
em um nó interno $N$ já cheio, são:
\begin{enumerate}
\item Copiar $N$ para uma área temporária $M$ com espaço para $n+1$ pointeiros
e $n$ chaves.
\item Inserir $(k,p)$ em $M$.
\item Copiar $P_1,K_1, ..., K_{\lceil n/2 \rceil -1}, P_{\lceil n/2 \rceil}$ de
$M$ para o nó $N$. 
\item Copiar $P_{\lceil n/2 \rceil + 1}, K_{\lceil n/2 \rceil+1}, ..., K_n,
P_{n+1}$ de $M$ para o novo nó $N'$.
\item Inserir $(K_{\lceil n/2 \rceil},N')$ no pai $N$.
\end{enumerate}
A figura~\ref{aula06:fig:btree5} mostra um exemplo da divisão de um nó
não-folha cheio e inserção do no pai $N$.
%
\begin{figure}[!htb]
\centering
\includegraphics[width=0.7\textwidth]{aula06-btree5}
\caption{Exemplo de uma divisão de nó não-folha cheio.}
\label{aula06:fig:btree5}
\end{figure}

\subsubsection{Remoção}

Os passos da remoção são:
\begin{enumerate}
\item Encontrar os registros a serem removidos, removê-los do
arquivo e do bucket (se necessário).
\item Remover (chave, pointeiro) do nó folha se não tiver bucket ou se 
o bucket estiver vazio.
\item Se o nó possuir poucas entradas devido a remoção, e as entradas 
do nó e seu vizinho couberem no mesmo nó, então \textbf{mesclar vizinhos}:
	\begin{enumerate}
	\item Inserir todas as chaves dos dois nós em um só (o da esquerda) e 
	remover o outro.
	\item Remover o pai do par $(K_{i-1}, P_i)$, onde $P_i$ é o ponteiro
	para o nó removido.
	\item Repetir o procedimento se o pai ficar com poucas entradas.
	\end{enumerate}
\item Senão, se o nó possuir poucas entradas, mas as entradas no nó
e no vizinho não couberem em um só, então \textbf{redistribuir ponteiros}:
	\begin{enumerate}
	\item Redistribuir os ponteiros entre o nó e o vizinho de modo
	que ambos tenham mais do que o número mínimo de entradas.
	\item Atualizar as chaves correspondentes do nó pai.
	\end{enumerate}
\end{enumerate}

As remoções podem se propagar para cima até que se encontre um nó com pelo 
menos $\lceil n/2 \rceil$ pointeiros.
Se o nó raiz possuir apenas um ponteiro após a remoção, ele é removido e seu filho
se torna a raiz.
A figura~\ref{aula06:fig:btree8} mostram o exemplo de remoção.
%
\begin{figure}[!htb]
\centering
\includegraphics[width=0.8\textwidth]{aula06-btree8}
\includegraphics[width=0.8\textwidth]{aula06-btree9}
\caption{Árvore B+ antes e depois da remoção de ``Srinivasan''.}
\label{aula06:fig:btree8}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Organização de arquivos}

Árvores B+ podem ser usadas diretamente para organizar arquivos
em vez de simplesmente para indexação. 
Nesse caso, os nós folhas armazenam registros em vez de ponteiros.
O problema da degradação de arquivo é resolvida usando essa solução.
A inserção e remoção são tratadas da mesma forma.

As folhas ainda precisam estar preenchidas até a metade visto
registros são mais longos do que pointeiros, 
o máximo de registros em um nó folha é menor do que o número de ponteiros
dos nós não-folha.

Para melhorar a utilização de espaço, pode-ser envolver mais vizinhos na 
redistribuição durante as divisões e mesclas.
Por exemplo, usar 2 vizinhos na redistribuição (para evitar divisões/mesclas)
resulta em cada nó tendo pelo menos $\lfloor 2n/3 \rfloor$ entradas.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Índices Hash}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Hashing estático}

Por definição, um \textbf{bucket} é uma unidade de armazenamento com um ou mais
registros. Tipicamente, um bucket pode ser um bloco de disco.
Em uma organização de arquivo com hash, o bucket de um registro é obtido diretamente
de sua chave de busca por meio da função hash.

Uma \textbf{função hash} mapeia todas as chaves de busca para buckets, e é usada
para localizar registros para acesso, inserção e remoção.
Registros com valores de chave de busca diferentes podem ser mapeados para o mesmo
bucket.
Para localizar um registro, todo o bucket deve ser varrido sequencialmente.

A figura~\ref{aula06:fig:hash1} mostra um exemplo de arquivo hash com hashing estático.
%
\begin{figure}[!htb]
\centering
\includegraphics[width=0.6\textwidth]{aula06-hash1}
\caption{Organização de arquivo hash para \emph{instructor}, com
\emph{dept\_name} como chave de busca.}
\label{aula06:fig:hash1}
\end{figure}

\subsubsection{Funções hash}

A pior função mapeia todas as chaves de busca para o mesmo bucket, o que 
o tempo de acesso proporcional ao número de registros do arquivo.

Uma função hash ideal é:
\begin{itemize}
\item \textbf{Uniforme} - cada bucket recebe o mesmo número de chaves
de busca, a partir do conjunto de todos os valores possíveis.
\item \textbf{Aleatória} - cada bucket recebe o mesmo número de 
chaves de busca, qualquer que seja a distribuição de chaves de busca real no
arquivo.
\end{itemize}

Funções típicas realizam o cálculo a partir da representação binária das chaves
de busca. 
Por exemplo, somando a representação binária dos caracteres e dividindo pelo número
de buckets.
O resto da divisão seria o bucket designado.

\subsubsection{Tratamento dos estouros de buckets}

Em caso de colisão, os registros que colidem ocupam o mesmo bucket e pode
ocorrer estouro do bucket (\emph{bucket overflow}).
O estouro pode ocorrer devido:
\begin{itemize}
\item Buckets insuficientes.
\item Desequilíbrio na distribuição dos registros.
Os motivos são:
	\begin{itemize}
	\item muitos registros com a mesma chave de busca.
	\item a função de hash não é uniforme.
	\end{itemize}
\end{itemize}

Embora a probabilidade de estouro possa ser reduzida, ela não pode
ser eliminada.
Ela pode ser tratata através de \textbf{buckets de estouro}.
No \textbf{encadeamento de estouro}, os buckets de estouro são ligados
por uma lista encadeada (ver figura~\ref{aula06:fig:hash2}).
%
\begin{figure}[!htb]
\centering
\includegraphics[width=0.5\textwidth]{aula06-hash2}
\caption{Exemplo de encadeamento de estouro.}
\label{aula06:fig:hash2}
\end{figure}

O esquema acima é chamado \textbf{endereçamento fechado} (\emph{closed hashing}).
Uma outra alternativa,
chamada \textbf{endereçamento aberto} (\emph{open hashing}), não usa buckets de estouro.
Porém, não é adequada para aplicações de banco de dados.

\subsubsection{Índices hash}

Hashing também pode ser usado como índices. 
Um \textbf{índice hash} organiza as chaves de busca com seus ponteiros para registros.

\subsubsection{Deficiências do hashing estático}

No hashing estático, a função $h$ mapeia chaves de busca para um número fixo de buckets.
Com o crescimento ou encolhimento do banco de dados:
\begin{itemize}
\item Se o número de buckets for baixo, e o arquivo crescer, o desempenho
irá cair devido aos estouros.
\item Se o número de buckets for alto, uma grande quantidade de espaço
será desperdiçada inicialmente.
\item Se o arquivo encolher, novamente o espaço será desperdiçado.
\end{itemize}

Uma solução seria reorganização periódica do arquivo com uma nova função de hash.
Porém, essa solução custa caro e interrompe operações sobre o arquivo.
Uma solução melhor é permitir que o número de buckets seja modificado
dinamicamente.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Hashing dinâmico}

Usado para banco de dados cujo tamanho costuma mudar, e permite que a função
de hash mude dinamicamente.
O \textbf{Hashing extensível} é uma das formas de hashing dinâmico.
A função de hash gera valores a partir de um intervalo elevado, tipicamente
inteiros com b-bits, onde $b = 32$.

Apenas um prefixo da função de hash é usado para indexar uma \textbf{tabela de buckets}.
Considere que a largura do prefixo seja de $i$ bits, $0 \leq i \leq 32$.
O tamanho da tabela de buckets é $2^i$, sendo inicialmente $i= 0$.
O valor $i$ cresce ou diminui junto com o banco de dados.

Múltiplas entradas da tabela de buckets podem apontar para o mesmo bucket. 
Assim, o número real de buckets é $< 2^i$. 
O número de buckets também muda dinamicamente pela sua mescla ou divisão.

Em uma hash extensível, cada bucket $j$ guarda o valor $i_j$. Todas as entradas
que apontam para o mesmo bucket tem o mesmo valor para os primeiros $i_j$ bits.
Para localizar o bucket contendo a chave de busca $k_j$:
\begin{enumerate}
\item Computar $h(K_j) = X$.
\item Usar os bits de maior ordem $i$ de $X$ como um deslocador na tabela
de buckets, e seguir o ponteiro para o bucket apropriado.
\end{enumerate}

\subsubsection{Inserção em estruturas de hash extensível}

Para inserir um registro com chave de busca $K_j$:
\begin{enumerate}
\item localizar o bucket apropriado $j$.
\item se tiver espaço no bucket $j$, inserir o registro no bucket.
\item senão, o bucket deve ser dividido e a inserção tentada de novo. 
Em alguns casos, são necessários buckets de estouro.
\end{enumerate}

Para dividir o bucket $j$ quando inserindo registro com a chave de busca $K_j$:
\begin{enumerate}
\item Se $i > i_j$ (mais de um apontador para o bucket $j$):
	\begin{enumerate}
	\item alocar um novo bucket $z$ e atribuir $i_j = i_z = (i_j+1)$.
	\item atualizar a segunda metade das entradas da tabela de 
	buckets que apontavam para $j$, fazendo-as apontar para $z$.
	\item remover os registros do bucket $j$ e reinseri-los 
	(em $j$ ou $z$).
	\item localizar o bucket para $K_j$ e inserir registro no bucket apropriado
	(realizar divisões sucessivas enquanto o bucket continuar cheio).
	\end{enumerate}

\item Se $i = i_j$ (apenas um ponteiro para o bucket $j$):
	\begin{enumerate}
	\item se $i$ atingir o limite $b$, ou se muitas divisões ocorrerem, criar um bucket
	de estouro.
	\item senão
		\begin{enumerate}
		\item incrementar $i$ e dobrar o tamanho da tabela de buckets.
		\item substituir cada entrada da tabela por duas entradas que
			apontam para o mesmo bucket.
		\item localizar a entrada na tabela de endereçamento para $K_j$.
		Agora $i > i_j$ estão no primeiro caso acima.
		\end{enumerate}
	\end{enumerate}

\end{enumerate}

A figura~\ref{aula06:fig:hash3} demostra a representação binária gerada pela função 
hash $h$ em uma chave de busca exemplo, enquanto que na figura~\ref{aula06:fig:hash4} ilustra
a estrutura do arquivo hash depois de 11 inserções.
%
\begin{figure}[!htb]
\centering
\includegraphics[width=0.6\textwidth]{aula06-hash3}
\caption{Função de hash extensível para o exemplo a seguir de inserção.}
\label{aula06:fig:hash3}
\end{figure}
%
\begin{figure}[!htb]
\centering
\includegraphics[width=0.7\textwidth]{aula06-hash4}
\caption{Estrutura do arquivo hash depois de 11 inserções.}
\label{aula06:fig:hash4}
\end{figure}


\subsubsection{Remoção em estruturas de hash extensível}

Para remover uma chave:
\begin{enumerate}
\item localizá-la no bucket e removê-la.
\item o bucket pode ser removido se ficar vazio (com as devidas
atualizações na tabela de buckets).
\item a mescla de buckets pode ser feita (pode mesclar apenas com
um bucket que tenha o mesmo valor $i_j$ e o mesmo prefixo $i_j-1$, se existir).
\end{enumerate}
A redução da tabela de buckets também é possível. Porém, a redução é cara
e deve ser feita apenas se o número de buckets for muito menor do que o tamanho
da tabela.

\subsubsection{Comparação com outros esquemas}

As vantagens do hash extensível são:
\begin{itemize}
\item O desempenho não degrada com o aumento do arquivo, sendo $C(n)=1$ se a 
função for uniforme e aleatória.
\item Sobrecarga de espaço é mínima.
\end{itemize}

As desvantagens são:
\begin{itemize}
\item Nível de indireção extra para localizar registros.
\item A tabela de buckets pode se tornar muito grande (maior que o espaço
disponível na memória).
	\begin{itemize}
	\item Não se pode alocar espaços contíguos em disco.
	\item Solução: usar uma árvore B+ para representar os registros em 
		uma tabela de buckets.
	\end{itemize}
\item Mudar o tamanho da tabela de endereço também é uma operação custosa.
\item Custo para recuperar os registros em ordem é alto.
\item Pior caso é $C(n) = n$.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Índices multidimensionais}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Os atributos usados em uma busca podem ser considerados como dimensões.
Consultas que envolvem buscas em mais de um atributo ou dimensão podem
usar dois tipo de índices.
\begin{itemize}
\item Índices unidimensionais.
\item Índices multidimensionais.
\end{itemize}

Em índices unidimensionais a chave de pesquisa é única. Também é possível
recuperar registros que correspondem a um dado valor (ou intervalo)
da chave de busca. Os tipos de índices que vimos anteriormente 
são por exemplo árvores B+ e tabelas hash.

\textbf{Índices multidimensionais} são usados para consultas em mais do que um
atributo (ou dimensão).
Como exemplo, um sistema de informações geográficas armazena objetos 
em um espaço bidimensional. As consultas que poderiam ser feitas são:
\begin{itemize}
\item Consultas de correspondência parcial.
\item Consultas de intervalo.
\item Consultas de vizinho mais próximo.
\item Consultas do tipo onde estou.
\end{itemize}
Outro exemplo utilizado em sistemas de decisão são cubos de dados que, em geral, 
utiliza a dimensão tempo nas consultas. Por exemplo, pode-se fazer consultas
de vendas de um produto para cada loja em um determinado período de tempo.

Nesses exemplos, índices unidimensionais apresentam limitações:
\begin{itemize}
\item Em consultas por intervalos, o número de blocos acessados pode ser excessivo. Imagine
que os passos envolvidos caso a consulta fosse realizada em uma árvore B+ são:
	\begin{enumerate}
	\item Usar um índice para cada uma das dimensões x, y.
	\item Obter os ponteiros da árvore B+ para os registros no intervalo de x.
	\item Obter os ponteiros da árvore B+ para os registros no intervalo de y.
	\item Fazer a interseção dos ponteiros.
	\item Examinar blocos da interseção.
	\end{enumerate}
\item Em consultas de vizinho mais próximo, não se sabe qual intervalo buscar.
\end{itemize}

A estruturas de índices multidimensionais podem ser baseadas em:
\begin{description}
\item[Índices bitmap] código sucintos (bits) par responder com eficiência 
consultas sobre múltiplas chaves.

\item[Estruturas baseadas em hash] a resposta da consulta pode não estar em um único bucket.
Contudo, pode estar em um número baixo de buckets. As estruturas são: arquivos
de grade e funções de hash particionado.

\item[Estruturas baseadas em árvores] não há correspondência entre os nós da árvore e blocos do disco.
Todavia, árvores podem ficar desbalanceadas e a eficiência nas atualizações
pode ser menor.
As estruturas são: índices de várias chaves, árvores \emph{kd}, árvore de quadrante,
e árvores R.
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Índices de bitmap}

\textbf{Chaves de busca compostas} são chaves de busca que possuem
mais de um atributo como em \emph{(branch\_name, balance)}.

\textbf{Índices de mapa de bits} (bitmap) foram projetados para responder com
eficiência consultas sobre mútiplas chaves.
Registros em uma relação devem possuir uma numeração sequencial. 
Dado um número $n$ deve ser fácil recuperar o registro $n$.

Um índice de bitmap é aplicável para atributos que assumem uma quantidade pequena de valores.
Exemplos são: sexo, país, estado, nível salarial (salário categorizado em níveis como 
0-9999, 10000-19999, 20000,50000, 50000-infinito).
Um mapa de bits é simplesmente um vetor de bits.

Um índice de bitmap sobre um atributo tem o um bitmap para cada valor possível
para esse atributo.
O bitmap tem tantos bits quantos forem os registros. 
Em um bitmap para o valor $v$, o bit para um registro é 1 se o 
registro possui o valor $v$, e 0 caso constrário.

Índices de bitmap são úteis para consultas por múltiplos atributos, e não muito úteis
para consultas por um único atributo.
Consultas são respondidas usando os seguintes operadores de bitmap:
\begin{itemize}
\item Interseção (\textbf{AND}).
\item União (\textbf{OR}).
\item Complementação (\textbf{NOT}).
\end{itemize}
Cada operação usa dois bitmaps de mesmo tamanho e aplica a operação nos bits
correspondentes para gerar o bitmap de resultado. Exemplos dessas operações são:
\begin{itemize}
\item Interseção -- 100110 \textbf{AND} 110011 = 100010
\item União --      100110 \textbf{OR} 110011 = 110111
\item Complementação -- \textbf{NOT} 100110 = 011001
\end{itemize}
Índices de bitmap geralmente são muito pequenos se comparados com o tamanho da tabela.

A figura~\ref{aula06:fig:bitmap1} mostra um exemplo de índice bitmap com a relação
de dois campos \emph{gender} e \emph{income\_level}. 
Por exemplo, em uma busca $gender = f(01101)$ e $income\_level = L2(01000)$ aplica-se a 
operação de interserção (AND) e resulta no bitmap $01000$.
%
\begin{figure}[!htb]
\centering
\includegraphics[width=0.6\textwidth]{aula06-bitmap1}
\caption{Índices bitmap para uma relação.}
\label{aula06:fig:bitmap1}
\end{figure}
%A operação de remoção precisa ser tratada de forma adequada.
%O \textbf{bitmap de existência} é necessário para operações de complementação,
%usada para averiguar se os registros ainda são válidos.

Quanto a implementação, bitmaps são empacotados em palavras, uma única palavra 
em uma instrução de CPU computa AND de 32 ou 64 bits de cada vez.
Por exemplo, um mapa com milhão de bits pode ser computado com apenas
31.250 instruções.

A contagem do número de 1s pode ser otimizada ao usar cada byte para indexar
um array de 256 posições.
Cada posição guarda a contagem de 1s na sua respectiva representação binária. 
Pode-se usar pares de bytes para agilizar o cálculo, com um custo
de memória adicional.
Em seguida, basta somar as contagens recuperadas.
Bitmaps podem ser usados nos nós folhas das árvores B+ em vez de listas 
de ponteiros de registros.
É vantajoso se $> 1/64$ dos registros tiver esse valor, supondo que o ponteiro
ocupe 64 bits.
Essa técnica combina vantagens dos bitmaps e das árvores B+.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Arquivos de grade}

Em arquivos de grade, há um espaço de pontos dispostos em uma grade.
Imagine que cada dimensão possue linhas de grade 
que particionam o espaço entre faixas.
Os pontos que caírem em uma linha de grade serão considerados pertencentes
à faixa da qual essa linha de grade é o limite inferior.
O número de linhas de grade em cada dimensão, assim como o espaçamento entre elas,
pode variar.

Cada região em que um espaço é particionado pode ser imaginada como um bucket
de uma tabela hash, e os pontos dentro dessa região são inseridos em um bucket
que pertence a essa região. Quando necessário, pode-se usar buckets de estouro.
A figura~\ref{aula06:fig:grade2} demonstra um exemplo de arquivo de grade
com buckets para cada região.
%
\begin{figure}[!htb]
\centering
\includegraphics[width=0.5\textwidth]{aula06-grade2}
\caption{Arquivo de grade com buckets.}
\label{aula06:fig:grade2}
\end{figure}

\subsection{Pesquisa}

Ao invés de usar uma tabela unidimensional de buckets, como em tabelas hash, 
o arquivo de grade usa tabelas auxiliares, ou \textbf{array de buckets}, cujo
número de dimensões é igual ao do arquivo de dados. 
Para realizar uma pesquisa, é preciso saber quais faixas delimitam os buckets
em cada dimensão.
A partir do array de buckets podemos determinar a região em que um ponto está.

A figura~\ref{aula06:fig:grade1} mostra um exemplo de arquivo de grade
com duas dimensões: salário (y) e departamento (x). 
As tabelas auxiliares indicam o valor de cada linha da grade.
%
\begin{figure}[!htb]
\centering
\includegraphics[width=0.5\textwidth]{aula06-grade1}
\caption{Arquivo de grade com duas dimensões.}
\label{aula06:fig:grade1}
\end{figure}

\subsection{Inserção}

Segue a mesma lógica da pesquisa. Se houver espaço no bucket para o registro novo,
não haverá nada mais a fazer.
Se não houver espaço, existem duas abordagens:
\begin{enumerate}
\item Adiciona-se buckets de estouro.
\item Reorganiza-se a estrutura, adicionando-se ou movendo as linhas da grade.
\end{enumerate}

\subsection{Desempenho}

Um problema importante no caso de altos números de dimensões é que o número de buckets
cresce exponencialmente com a dimensão. Por exemplo, 3 dimensões com 10 faixas em cada dimensão
resulta em $10^3 = 1000$ blocos.

O ideal é usar poucos buckets, e distribuir bem os pontos para evitar estouro
de buckets.  Importante notar que esse ideal é dificil alcançar se os pontos
não tem uma distribuição uniforme.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Hash particionado}

Funções de \textbf{hash particionado} aplicam uma função hash sobre uma lista
de atributos.
Cada valor de atributo contribui para formar parte da chave hash gerada.
A figura~\ref{aula06:fig:particionado1} mostra o uso de 4 $bits$ para um atributo A
e  6 $bits$ para um atributo B, formando assim um identificador de 10 $bits$.
Essa tabela hash contém 1024 buckets ($2^{10}$).
%
\begin{figure}[!htb]
\centering
\includegraphics[width=0.5\textwidth]{aula06-particionado1}
\caption{Chave hash para uma tabela com 1024 buckets e 10 bits.}
\label{aula06:fig:particionado1}
\end{figure}

Comparado com arquivos de grade, o hash particionado tem pouca utilidade em
consultas por intervalos e consultas de vizinho mais próximo.
Nessa caso a distância física entre os pontos não reflete na proximidade dos números
de buckets.

Os arquivos de grade são mais adequados para consultas de vizinho mais próximo e consultas
em intervalos. Porém, o número alto de dimensões pode levar a muitos buckets vazios ou
quase vazios.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Índices de várias chaves}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Árvores kd}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Árvores de quadrante}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Árvores R}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Exercícios}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

